---
title: From Greenfield to Minefield and back
excerpt: From Greenfield to Minefield and back description alabala
image: images/greenfied.webp
tags:
  - angular
  - structure

og:
  - title: true
    description: true
  - image: images/front-enh-nobg.png
    image:alt: A shiny red apple with a bite taken out
---

# From greenfield to minefield and back

import { Tags } from '../../../components/tags/';

<Tags />

## The dream

Imagine starting on a fresh project, there is no legacy, there is no one to blame it is up to you and your team to build this state of the art project.
And as months go by and new colleagues join they will open the project read through the code and stop every 5 minutes to admire what you've wrote.

import Image3 from '~/media/from-greenfield-to-minefield/Slide3.jpeg?jsx';

<p align="center">
  <Image3 />
</p>

## The result

Yeah, unfortunately this is not the common case but maybe it will be for you with the advices I share. Lets go through the timeline of the project together and see where things might have gone wrong.

import Image4 from '~/media/from-greenfield-to-minefield/Slide4.jpeg?jsx';

<p align="center">
  <Image4 />
</p>

## DISCLAIMER

import Image5 from '~/media/from-greenfield-to-minefield/Slide5.jpeg?jsx';

<p align="center">
  <Image5 />
</p>

This is not a step by step guide or a recipe for how to build and scale a project from scratch.
In this article I will tell share the story of our journey so far.
What are some key decisions that we made, what are the problems that we stumbled upon and how we tackled them.
I'll go in depth about the more technical parts.
I would also cover some of the more architectural topics and a lot of them are polarizing so I'll not give statements and tell you which is best but will be more pc and try to give a more philosophical view and point in the direction in which you should think about when solving them.

## Project timeline

I will use the project timeline to structure the article.
I will stop at some key decisions and milestones and share my thoughts on them.
I will also share the size of the team at that point and the challenges that we faced.

import Image6 from '~/media/from-greenfield-to-minefield/Slide6.jpeg?jsx';

<p align="center">
  <Image6 />
</p>

## Choosing a framework

This is one of the controvertial topics that I will not go into much detail but rather share my experience and the reasons why we chose Angular.
For context the project is a web application that is used by doctors and patients. It is a medical platform that helps doctors manage their patients and their health.
The project started in late 2019. The first memebers of the team were mostly BE oriented and had experience with Java and Spring.
So Angular made a lot of sense because the mental model is similar (i.e. class components,services,DI) and the language is also similar (i.e. typescript).
So because we were a small team and we could use the help of BE developers Angular sounded like a good choice.
Another important thing to mention is that we don't have architects. We are equally responsible for the architecture of the project.
When we have to make some technical decision we go wtih an RFC. Usually one person - the one with most experience and interest in the topic writes the RFC and then we discuss it with the team and make a decision.
This approach has pros and cons. The pros are that everyone is involved in the decision making process and everyone is responsible for the outcome. The cons are that it takes time, it is difficult to please everyone, sometimes there is no right answer.
In this case Angular also made sense because at the time it was quite mature and opinionated: you need a router - there is a built-in one, you need to do http requests - there is a built-in service for that, you need to do testing - built-in.
So I think if we choose React we would have to spend more time on the initial setup and we would have to make more decisions about the architecture of the project.
Also Angular was quite stable for a couple of years and everything new was backwards compatible (I think they learned their lesson with angularJs). While react was constantly evolving (i.e. class components then functional components, hooks, server components, etc...) and there were a lot of breaking changes.
A great article on that topic is [this one](https://betterprogramming.pub/i-almost-got-fired-for-choosing-react-in-our-enterprise-app-846ea840841c).

### About frameworks

> “…web dev is a pop culture with no regard for history\, dooming each successive generation to repeat the blunders of the old\, in a cycle of garbage software\, wrapped in ever\-escalating useless animations\, transitions\, and framework rewrites\.”
> a quote from a favourite [blog post](https://www.baldurbjarnason.com/2021/100-things-every-web-developer-should-know/)

The framework is just a tool which helps you get the job done. Think about what suits better the business case and helps you build the features that you need. It is easier learning new framework then making the wrong framework fit your case.

import Image8 from '~/media/from-greenfield-to-minefield/Slide8.jpeg?jsx';

<p align="center">
  <Image8 />
</p>

## Choosing a testing framework

As I mentioned earlier Angular comes with a built-in testing framework. It is called Karma. It is a test runner that runs in the browser.
However, it spawns a new browser which is slow. So we decided to use Jest. It is a test runner that runs in the command line.
It is easier to integrate with the CI/CD pipeline. It is supposed to be faster. It has a lot of features out of the box.
To be honest I am not sure if we made the right choice as we spent a lot of time optimizing the tests and making them run faster.

import Image9 from '~/media/from-greenfield-to-minefield/Slide9.jpeg?jsx';

<p align="center">
  <Image9 />
</p>

A side note on testing. In my years of experience I see that often tests are often neglected.
I've also been there done that. It becomes ugly after a while. Not gonna state the benefits of tests.
But for large projects that grow and evolve and require refactoring tests are really helpful. Especially for the FE where verifuing the ui is hard enough. I can say that if you put the initial effort to setup the testing framework and grow the test code a bit, it becomes easy to write tests.
And it is never too late to set the tests and start covering old functionality together with the new one. I've also done that.

import Image11 from '~/media/from-greenfield-to-minefield/Slide11.jpeg?jsx';

<p align="center">
  <Image11 />
</p>

The company grew. I joined 🎉. Two teams were formed. We had to choose an approach for the repo.
We decided to go with monorepo. We had the BE and FE together.
As we wanted to move fast this way we could do MRs containing changes in both the places.
Sharing code between the two was easy. We had a shared library where we put common code.
We went with nx as a tool to manage the monorepo.
It has some nice features like enforcing module boundaries, dependency graph, building and testing only the affected projects.
And the configuration is quite simple. You just have to add the project to the nx.json file and you are good to go.
Also there is linting and formatting out of the box.

```json
/* nx.json */
{
  // ...
  "implicitDependencies": {
    "angular.json": "*",
    // ...
    ".eslintrc.json ": "*"
  },
  "projects": {
    "patient-portal": { "tags": [] },
    "staff-portal": { "tags": [] },
    "logging": { "tags": [] },
    "refmd-portal": { "tags": [] }
  }
  // ...
}
```

--

```json
// .eslintrc.json
"@nrwl/nx/enforce-module-boundaries": [
  "error",
  {
    "enforceBuildableLibDependency": true,
    "allow": [],
    "depConstraints": [
      {
        "sourceTag": "*",
        "onlyDependOnLibsWithTags": ["*"]
      }
    ]
  }
]
```

The team continued growing. We started working on a new part of the product . We had to add another project.
We needed to share code between the projects so we just added a shared library where we put common code.
This way we could quickly reuse components, srevices, etc...

Surely, this approach wouldn't scale well. Although it was easy at first to keep the pace it presented some chalenges.
One problem that we hit shortly was regarding the tests.
When it comes to testing in Angular there are a couple of approaches.
You could either do pure unit tests where you test the component in isolation. You mock the dependencies and test the component logic.
Or you could do integration tests where you test the component with its dependencies. You mock the http requests and test the component in the context of the app.
A lot of times integration tests made more sense to us. We wanted to test the component in the context of the app. We wanted to test the interactions between the components.
However, this approach had a drawback. We had to import the modules that the component depends on. And if the component depends on a lot of modules this could be cumbersome.
So the easiset approach was to just import the shared module. This way we could import all the dependencies in one place. Unfortunately, this way we were importing a lot of stuff that we didn't need.
And the started to become pretty obvious

import Image14 from '~/media/from-greenfield-to-minefield/Slide14.jpeg?jsx';

<p align="center">
  <Image14 />
</p>

So, the takeaway here is that you need to overlook the tests and make sure the execution time is reasonable. And if it is growing, why?
In our case we had to refactor the tests and make sure we are importing only the modules that we need.
And we had to become more strict about doing mr reviews of unit tests and making sure we are not importing unnecessary modules.
Also with the monorepo approach we had to be careful about the dependencies between the projects.
Suddenly the shared library became a bin where we put everything.

import Image15 from '~/media/from-greenfield-to-minefield/Slide15.jpeg?jsx';

<p align="center">
  <Image15 />
</p>

Anyhow this whole library strategy started to "shine" we had to add yet another project.

import Image16 from '~/media/from-greenfield-to-minefield/Slide16.jpeg?jsx';

<p align="center">
  <Image16 />
</p>

Now the shared library started to become a mess. There were stuff that Project1 and Project2 needed but Project3 didn't and vice versa.

import Image17 from '~/media/from-greenfield-to-minefield/Slide17.jpeg?jsx';

<p align="center">
  <Image17 />
</p>

We had to split the shared library into two. One for sharing stuff across all projects and the other one for sharing between projects.

import Image18 from '~/media/from-greenfield-to-minefield/Slide18.jpeg?jsx';

<p align="center">
  <Image18 />
</p>

This aproach wouldn't scale well. Although it was easy at first to keep the pace it presented some chalenges.
We were finally forced to rethink our strategy.

To sum up the takeaways:
One big shared library is definetly not the way to go if you want to scale.
You are not only importing things you don't need but also makes hard to find stuff.

import Image19 from '~/media/from-greenfield-to-minefield/Slide19.jpeg?jsx';

<p align="center">
  <Image19 />
</p>

So what is the solution? As with everything in software development it depends and there are tradeoffs.
The engineers from the team have all worked with different approaches and we had to find a common ground.
The first and most common one that we all had experience with was one library per component.

import Image21 from '~/media/from-greenfield-to-minefield/Slide21.jpeg?jsx';

<p align="center">
  <Image21 />
</p>

My personal expereince with that approach was the most extreme one:
One library per component.
Separated in a different repo.
Exposed as an npm package in an internal registry.

And it was hell to develop test and maintain. I remember the npm link would often not work as expected. Versioning was not clear. Release process was cumbersome.
And what would end up happenning is that at the end of the day every consumer needed the latest version anyways.
I guess the others had similar experience and we decided to go with a different approach.

import Image22 from '~/media/from-greenfield-to-minefield/Slide22.jpeg?jsx';

<p align="center">
  <Image22 />
</p>

We evaluated the DDD (Domain driven design) appraoch since we were already using it in some places in the BE.
The good thing about it is that it is easy to separate the domain logic. But only when you have clearly defined context boundries.
In our case we feared that we would end up with a lot of overhead.
And that we would often have to refactor and move code around just for the sake of fitting the DDD approach.
So we decided to check the nx approach.

import Image23 from '~/media/from-greenfield-to-minefield/Slide23.jpeg?jsx';

<p align="center">
  <Image23 />
</p>

We would have libraries separated by context. More specifically we would have feature, ui, data acess and util libraries.
This way if we have some clearly defined bounded context we can extract it into a fully functional feature library.
Otherwise we can share reusable blocks into ui and data access libraries. This sounded like a good middle ground.

The takeaways here are: once you need to share code between projects you need to think about structure.
If you don't then you are just posponing the problem.

import Image24 from '~/media/from-greenfield-to-minefield/Slide24.jpeg?jsx';

<p align="center">
  <Image24 />
</p>

We were back on track and we continued developing features. We had a functional part of the product. It was time to test it with real users.
This would verify our assumptions and help us prioritize the next features.

import Image25 from '~/media/from-greenfield-to-minefield/Slide25.jpeg?jsx';

<p align="center">
  <Image25 />
</p>

We didn't have to wait long before we got the first unexpected feedback.
It turned out the internet was not as realiable in the medical centers as we thought.
We had to improve the performance of the app. We had to make sure it works with bad internet connection.
Two areas we could improve were load times and request timeouts.

import Image26 from '~/media/from-greenfield-to-minefield/Slide26.jpeg?jsx';

<p align="center">
  <Image26 />
</p>

Best would be to improve the FCP (First Contentful Paint). And what better place to start than the bundle size.
When we investigated the bundle size there were a lot of surprises.
It turned out that ~20% of the bundle size was coming from moment.js because the way we were importing it was not tree-shakeable.
So all of the bundles for all locales were included.
Also because we were not using es6 imports for some of the npm packages we were using we had to include the whole package (i.e. rxjs and lodash).
Which would make another ~7% of the bundle size.
So in total we could reduce the bundle size by ~27% just by using es6 imports and tree-shaking momentjs properly.

import Image27 from '~/media/from-greenfield-to-minefield/Slide27.jpeg?jsx';

<p align="center">
  <Image27 />
</p>

Another way to improve the UX is to provide faster FP (First Paint).
We could do that by using SSR (Server Side Rendering). With SSR there comes a lot of complexity.
You have to have a node server that renders the app. You have to work around the browser APIs. You have to be cautios using urls and so on.
We could also do that by manually inlining the critical css and js.
We decided to go with the second approach as it was easier to implement and maintain.

import Image28 from '~/media/from-greenfield-to-minefield/Slide28.jpeg?jsx';

<p align="center">
  <Image28 />
</p>

Another area for improvement was request timeouts. At first if a request times out we just showed a generic error so the user wouldn't know the cause of the problem.
We decided to implement linear backoff. This way we would retry the request a couple of times before showing the error.

import Image29 from '~/media/from-greenfield-to-minefield/Slide29.jpeg?jsx';

<p align="center">
  <Image29 />
</p>

```ts
intercept(request: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>> {
  const id = request.headers.get(RequestIdHeader);
  const requestRetries = this.failedRequestsService.getFailedRequest(id)?.retries || 1;
  return next.handle(request).pipe(timeout(requestRetries * backoffInterval));
}
```

The takeaways:

- revise bundle size everytime you add a new npm package;
- keep an eye on core web vitals;

and another favorite quote of mine:

_"Tight feedback loops are magic: live reloading is magical. Hot module replacement less so. With live reload, your development browser automatically reloads your dev page when your code changes. If you suck and your page loads slowly, then you suffer. Hot module replacement hides the pain and lets you pass the suffering onto the user."_

import Image30 from '~/media/from-greenfield-to-minefield/Slide30.jpeg?jsx';

<p align="center">
  <Image30 />
</p>

The project was growing. We had a lot of features. We had a lot of components. We had a lot of services.
We hit our first comlicated state management problem.
So far we've used the most basic approach. We had a service that kept the state and exposed it as an observable.

```ts
export class StateService {
  private state = new BehaviorSubject<any>({});
  state$ = this.state.asObservable();
  setState(state) {
    this.state.next(state);
  }
}
```

However, we found ourselves on a page where we had to enhance pdf documents. We had to link and categorize pages, leave notes, create entities for each page, etc...
So our simple appriach beacame poluted with complicated rxjs statements. There were no set rules (i.e. no immutablity of the state).

import Image33 from '~/media/from-greenfield-to-minefield/Slide31.jpeg?jsx';

<p align="center">
  <Image33 />
</p>

So we had to rethink our approach and find something that would help us in such complicated scenarios.
We all had previous eperience with Redux in the form of ngrx.
We didn't like it - too much boilerplate, too much ceremony, too much code for simple things.
It requires that all of the engineers know it well and use it properly.
And even then it is easy to create an unbearable mess.
So we decided to look for an alternative.

import Image34 from '~/media/from-greenfield-to-minefield/Slide32.jpeg?jsx';

<p align="center">
  <Image34 />
</p>

We found akita which was lightweight, didn't require a lot of boilerplate and it played well with Angular's services.

import Image35 from '~/media/from-greenfield-to-minefield/Slide33.jpeg?jsx';

<p align="center">
  <Image35 />
</p>

Overall I'm glad we survived so long without management library. Living through the pain of state management thought us what are the gotchas
and what are the things that we need to look for in a library.

import Image40 from '~/media/from-greenfield-to-minefield/Slide40.jpeg?jsx';

<p align="center">
  <Image40 />
</p>

- There were a lot of other forks on the road along the way. How to do styling, logging, observability?
- Shall we use MFE (Micro Frontends)?
- How to implement our own design system? (We did btw. I will tell you about it in another article).
- How to improve UX? What are available rendering strategies? (I also have an article on that topic).
- and so on and so on...

Hopefully, the takeaways from this article will help you avoid some of the mistakes we made.
And your greenfield project will stay green for longer. And if it becomes a minefield you will know how to get out of it.
